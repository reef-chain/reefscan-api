[{"address":"0x0000000000000000000000000000000000000803","args":[],"compilerVersion":"v0.6.0+commit.26b70077","filename":"contracts/dex/DEX.sol","name":"DEX","optimization":true,"runs":200,"source":{"contracts/dex/DEX.sol":"pragma solidity ^0.6.0;\n\nimport \"./IDEX.sol\";\nimport \"../utils/SystemContract.sol\";\nimport \"../token/IMultiCurrency.sol\";\n\ncontract DEX is SystemContract, IDEX {\n    /**\n     * @dev Get liquidity of the currency_id_a and currency_id_b.\n     * Returns (liquidity_a, liquidity_b)\n     */\n    function getLiquidity(address tokenA, address tokenB)\n    public\n    view\n    override\n    systemContract(tokenA)\n    systemContract(tokenB)\n    returns (uint256, uint256)\n    {\n        require(tokenA != address(0), \"DEX: tokenA is zero address\");\n        require(tokenB != address(0), \"DEX: tokenB is zero address\");\n\n        uint256 currencyIdA = IMultiCurrency(tokenA).currencyId();\n        uint256 currencyIdB = IMultiCurrency(tokenB).currencyId();\n\n        uint256[3] memory input;\n\n        input[0] = 0;\n        input[1] = currencyIdA;\n        input[2] = currencyIdB;\n\n        uint256[2] memory output;\n\n        assembly {\n            if iszero(\n                staticcall(gas(), 0x0000000000000000405, input, 0x60, output, 0x40)\n            ) {\n                revert(0, 0)\n            }\n        }\n        return (output[0], output[1]);\n    }\n\n    /**\n     * @dev Swap with exact supply.\n     * Returns (target_amount)\n     */\n    function swapWithExactSupply(address tokenA, address tokenB, uint256 supplyAmount, uint256 minTargetAmount)\n    public\n    view\n    override\n    systemContract(tokenA)\n    systemContract(tokenB)\n    returns (uint256) {\n        require(tokenA != address(0), \"DEX: tokenA is zero address\");\n        require(tokenB != address(0), \"DEX: tokenB is zero address\");\n        require(supplyAmount != 0, \"DEX: supplyAmount is zero\");\n\n        uint256 currencyIdA = IMultiCurrency(tokenA).currencyId();\n        uint256 currencyIdB = IMultiCurrency(tokenB).currencyId();\n\n        uint256[6] memory input;\n\n        input[0] = 1;\n        input[1] = uint256(msg.sender);\n        input[2] = currencyIdA;\n        input[3] = currencyIdB;\n        input[4] = supplyAmount;\n        input[5] = minTargetAmount;\n\n        uint256[1] memory output;\n\n        assembly {\n            if iszero(\n                staticcall(gas(), 0x0000000000000000405, input, 0xC0, output, 0x20)\n            ) {\n                revert(0, 0)\n            }\n        }\n        return output[0];\n    }\n}\n","contracts/dex/IDEX.sol":"pragma solidity ^0.6.0;\n\ninterface IDEX {\n    // Get liquidity of the currency_id_a and currency_id_b.\n    // Returns (liquidity_a, liquidity_b)\n    function getLiquidity(address tokenA, address tokenB) external view returns (uint256, uint256);\n\n    // Swap with exact supply.\n    // Returns (target_amount)\n    function swapWithExactSupply(address tokenA, address tokenB, uint256 supplyAmount, uint256 minTargetAmount) external view returns (uint256);\n}\n","contracts/token/IMultiCurrency.sol":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.0;\n\ninterface IMultiCurrency {\n    function currencyId() external view returns (uint256);\n}\n","contracts/utils/SystemContract.sol":"pragma solidity ^0.6.0;\n\ncontract SystemContract {\n    modifier systemContract(address addr) {\n        bytes memory addrBytes = abi.encodePacked(addr);\n        for (uint i = 0; i < 12; i++) {\n            require(addrBytes[i] == 0, \"not a system contract\");\n        }\n        _;\n    }\n}\n"},"target":"","license":"none","contractData":null,"timestamp":1670838475636,"approved":true,"createdAt":"2023-05-18T10:18:57.132Z","updatedAt":"2023-05-18T10:18:57.132Z"}]